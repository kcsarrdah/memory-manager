Memory Pool Library
A lightweight, efficient custom memory management system designed for applications requiring fine-grained control over memory allocation patterns.
What is it?
A memory pool that pre-allocates a fixed chunk of memory and manages it internally, reducing overhead from frequent allocations/deallocations.
Key Features

Fixed-size memory allocation with customizable pool size
Support for aligned memory allocation
Automatic defragmentation
Memory block reuse
Thread-unsafe (single-threaded use only)
Memory usage tracking
Zero-allocation support
Efficient memory reuse

Why use it instead of standard allocation?

Reduces memory fragmentation
Faster allocation/deallocation (no system calls)
Predictable memory usage
Better cache locality
Lower overhead for frequent allocations
Fixed memory footprint

How it Works

Initializes a fixed memory block
Maintains a linked list of memory blocks
Tracks used/free blocks
Automatically defragments when needed
Aligns memory as requested

Usage
Basic Setup
cppCopy#include "memory_pool.h"

// Create a 1MB pool
MemoryPool pool(1024 * 1024);
Common Operations
cppCopy// Allocate memory
void* ptr = pool.allocate(1024);  // Standard allocation
void* aligned = pool.allocate(1024, 16);  // 16-byte aligned allocation

// Free memory
pool.deallocate(ptr);

// Check memory status
size_t used = pool.getUsedSize();
bool empty = pool.isEmpty();
size_t free = pool.getFreeSize();
CMake Integration
cmakeCopy# In your CMakeLists.txt
add_subdirectory(memory_manager)
target_link_libraries(your_project PRIVATE memory_manager)
Best Practices

Choose pool size based on maximum memory needs
Deallocate memory when no longer needed
Use alignment for performance-critical data
Monitor memory usage with provided methods
Consider fragmentation in allocation patterns

Limitations

Fixed maximum size
No automatic growth
Not thread-safe
No memory ownership tracking